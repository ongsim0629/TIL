## 19.3 프로토타입 객체
프로토타입 객체 : 객체간 상속을 구현하기 위해 사용된다.

프로토타입 : 객체의 상위 객체 역할을 하는 객체, 다른 객체에 공유 프로퍼티를 제공한다.
프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 사용할 수 있다.

프로토타입은 객체가 생성될 때 객체 생성 방식에 따라 결정되고 [[prototype]]에 저장된다.
- 객체 리터럴에 의해 생성된 객체 : Object.prototype
- 생성자 함수에 의해 생성된 객체 : 생성자 함수의 prototype에 바인딩되어 있는 객체

[[prototype]] 내부 슬롯에는 직접 접근할 수 없지만, __proto__ 접근자 프로퍼티를 통해 내부 슬롯이 가리키는 프로토타입에 간접적으로 접근할 수 있다.
constructor를 통해 생성자 함수에 접근하고
생성자 함수는 자신의 prototype을 통해 프로토타입에 접근한다.

### 19.3.1 접근자 프로퍼티
__proto__ 는 접근자 프로퍼티다.
내부슬롯은 프로퍼티가 아니다.
접근자 프로퍼티는 자체적으로 값을 갖지 않고 접근자 함수(getter, setter)로 구성된 프로퍼티다.

접근자 프로퍼티를 통해 프로토타입에 접근하면 getter 함수가 호출된다, 접근자 프로퍼티로 새로운 프로토타입을 할당하면 setter 함수가 호출된다.
```
obj.__proto__ = parent; // obj 객체의 ㅍ로토타입 교체
```

__proto__ 접근자 프로퍼티는 Object.prototype의 프로퍼티이고 상속을 통해 사용하는 것이다.
왜 __proto__를 이용할까? : 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서,
프로토타입 체인은 단방향 링크드 리스트로 구현되어야한다. -> 종점이 존재하지 않으면 검색할 때 무한루프에 빠지게 된다.

__proto__ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.
모든 객체가 __proto__ 접근자 프로퍼티를 사용할 수 있는 것은 아니다. : 직접 상속으로 Object.prototype을 상속받지 않는 객체를 생성할 수도 있다.
그래서 __proto__ 대신, Object.getPrototypeOf 메서드와 Object.setPrototypeOf 사용하는 것이 더 좋다.

### 19.3.2 함수 객체의 prototype 프로퍼티
prototype 프로퍼티 : 생성자 함수가 생성할 인스턴스의 프로토타입을 나타낸다.
따라서 non-constructor인 애들은 prototype 프로퍼티를 갖지 않는다.
__proto__ 접근자 프로퍼티와 prototype 프로퍼티는 동일한 프로토타입을 가리킨다.

### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수
constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.

## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성한 생성자 함수다.
하지만 new 연산자랑 생성자 함수 호출하는 방법 말고 다른 방법 (리터럴 표기법)에 의해 생성된 객체는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자함수라고 단정 지을수 없다.

Object 생성자 함수에 인수를 전달하지 않거나 undefine, null 인수로 전달하면서 호출하면 내부적으로는 추상 연산을 호출해서 Object.prototype을 프로토타입으로 갖는 빈 객체를 생성한다.
인수가 전달된 경우에는 인수를 객체로 변환한다.

객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.
리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다. => 프로토타입과 생성자 함수는 쌍으로 존재한다.

## 19.5 프로토타입의 생성 시점
결국 모든 객체는 생성자 함숭와 연결되어있다.
