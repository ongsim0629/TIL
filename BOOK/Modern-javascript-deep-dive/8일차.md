# 16장 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드
ECMAScript 사양에서 자바스크립트 엔진이 객체를 어떻게 처리할 지 내부적으로 관리하기 위해 사용된다. 
개발자가 접근하거나 수정할 수 없으며, 이중 대괄호로 감싸져 있다.
하지만 일부 내부 슬롯과 내부 메서드는 간접적으로 접근할 수 있는 수단이 제공된다.
ex) 프로퍼티의 경우
```
consto o = {};
o.[[prototype]]; // 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 직접 접근할 수 없다.
o.__proto__; // 하지만 간접적으로 접근할 수 있다.
```

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체
자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.
객체의 참조, 프로퍼티 키를 매개변수로 전달!
```
const person = {
  name: 'Lee';
};

console.log(Object.getOwnPropertyDescriptor(person,'name'));
//{value: "Lee", writable: true, enumerable: true, configurable: true}
```
존재하지 않는 프로퍼티 or 상속 받은 프로퍼티 -> undefined
getOwnPropertyDescriptors 메서든느 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는프로퍼티 디스크립터 객체들을 반환한다.

## 16.3 데이터 프로퍼티와 접근자 프로퍼티
- 데이터 프로퍼티 : 키와 값으로 구성된 일반적인 프로퍼티
- 접근자 프로퍼티 : 자체적으로는 값을 갖지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

- ### 16.3.1 데이터 프로퍼티
- 데이터 프로퍼티는 value, writable, enumerable, configurable 의 프로퍼티 어트리뷰트를 생성할 때 기본값으로 자동 정의된다.
- 이때 value는 프로퍼티 값으로 초기화 되고 나머지는 true로 초기화된다. (동적 추가시에도 동일)

- ### 16.3.2 접근자 프로퍼티
- 접근자 함수로 구성된 프로퍼티 (접근자 함수는 getter/ setter 함수라고도 부른다.)
- get, set, enumerable, configurable

메서드 앞에 get, set 붙은 애들 -> getter, setter
getter, setter의 함수이름이 접근자 프로퍼티이다. -> 자체적인 값을 가지지는 않지만, 값을 읽거나 저장할 때 관여한다.

+) 프로토타입은 객체의 부모 역할을 하는 객체, 프로토타입 체인은 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조

## 16.4 프로퍼티 정의
새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정하는 것
Object.defineProperty 메서드를 사용한다.
인수로는 객체의 참조와 프로퍼티 키, 프로퍼티 디스크립터 객체를 전달한다.
이때 디스크립터 객체를 누락시키면 undefined, false가 기본값이다. (value, get, set) -> undefined 이고 (writable, enumerable, configurable) -> false
Object.defineProperties를 사용하면 여러 개의 프로퍼티 한 번에 정의할 수 있다.

## 16.5 객체 변경 방지
### 16.5.1 객체 확장 금지
Object.preventExtensions 메서드 사용, Object.isExtensible 메서드로 확인
객체의 프로퍼티 추가가 (동적 추가, Object.definePropery) 금지된다.

### 16.5.2 객체 밀봉
Object.seal 메서드 사용, Object.isSealed 메서드로 확인
읽기와 쓰기만 가능 (추가, 삭제, 프로퍼티 어트리뷰트 재정의 금지 -> configurable이 false이다.) + 값 갱신은 가능하다.

### 16.5.3 객체 동결
Object.freeze 메서드 사용, Object.isFrozen 메서드로 확인
읽기만 가능 (추가, 삭제, 프로퍼티 어트리뷰트 재정의 금지, 값 갱신 금지 -> writable, configurable이 false다.)

### 16.5.4 불변 객체
지금까지 언급되었던 메서드들은 얕은 변경 방지여서 중첩 객체까지는 영향을 주지 못한다.
중첩 객체도 변경 불가능한 불변 객체를 구현하려면 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야한다.

# 17장 생성자 함수에 의한 객체 생성
## 17.1 Object 생성자 함수
new 연산자 + Object 생성자 =>> 빈 객체 반환
```
const person = new Object();
```
생성자 함수 : new 연산자와 함께 호출하여 객체를 생성하는 함수
인스턴스 : 생성자 함수에 의해 생성된 객체

## 17.2 생성자 함수
### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점
객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만 생성한다.
### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점
프로퍼티 구조가 동일한 객체 여러 개를 편하게 생성할 수 있다.

+) this
this: 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이다.
가리키는 값은 함수 호출 방식에 따라 동적으로 결정된다.

생성자 함수 : 일반 함수와 동일하게 정의하되, new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.

### 17.2.3 생성자 함수의 인스턴스 생성 과정
생성자 함수의 역할 : 인스턴스 생성 (필수) + 인스턴스 초기화 (옵션)
자바스크립트 엔진은 암묵적인 처리로 인스턴스를 생성하고 반환한다. 그 과정은 다음과 같다.
1. 인스턴스 생성과 this 바인딩
   - 암묵적으로 빈 객체를 생성하고, 인스턴스는 this에 바인딩 된다. (런타임 이전에 실행된다.)
2. 인스턴스 초기화
   - 생성자 함수의 코드가 한 줄씩 실행되면서 this에 바인딩 되어 있는 인스턴스를 초기화한다. -> 개발자의 역할
3. 인스턴스 반환
   - 인스턴스가 바인딩된 this를 암묵적으로 반환한다.
   - return문에 다른 객체 명시적으로 반환하면 this가 반환되지 못한다.
   - 이때 반환 값이 원시 값이면 원시 값 반환은 무시되고 this가 반환된다.
   - 따라서 생성자 함수 내부에서는 return문을 생략해라

### 17.2.4 내부 메서드 [[Call]]과  [[Construct]]
함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다. (일반 객체가 가지고 있는 내부 슬롯과 내부 메서드 모두 가지고 있기 때문에)
거기에 함수 객체만을 위한 내부 슬롯과 내부 메서드를 추가로 갖고 있다 ([[Environment]],[[FormalParamenters]], [[Call]], [[Construct]])

- 일반 함수로 호출되면 : 함수 객체의 내부 메서드 [[Call]]이 호출된다.
- 생성자 함수로서 호출되면 : 함수 객체의 내부 메서드 [[Construct]]가 호출된다.

모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.

### 17.2.5 constructor와 non-constructor의 구분
함수 객체를 생성할 때 함수 정의 방식에 따라 constructor와 non-constructor로 구분한다.
- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드, 화살표 함수
  (ECMA 사양에서 메서드는 ES6의 메서드 축약 표현만을 의미한다.)

### 17.2.6 new 연산자
일반 함수와 생성자 함수에는 특별한 형식적 차이가 없고, new 연산자와 함께 함수를 호출하면 내부 메서드 [[Call]]이 호출되는 것이 아니라  [[Construct]]가 호출된다. 이때 함수는 constructor여야 한다. (생성자 함수를 new 연산자 없이 호출하는 것도 마찬가지)

생성자 함수는 일반적으로 첫 문자를 대문자로 명명해서 일반 함수랑 구별하자.

### 17.2.7 new.target
new.target (메타 프로퍼티) : new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. (일반 함수에서는 undfined) -> constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용

+) 메타 프로퍼티를 지원하지 않는 경우 (IE 등) : 스코프 세이프 생성자 패턴 사용하기, 프로토타입을 이용해서도 new 연산자와 함께 호출되었는지 확인할 수 있다.
