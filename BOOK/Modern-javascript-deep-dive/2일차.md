# 4장
## 4.1 변수란 무엇인가? 왜 필요한가?
컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.
메모리는 메모리셀의 집합체인데 셀 하나의 크기는 1바이트이며, 컴퓨터는 1바이트 단위로 데이터를 저장하거나 읽는다.
자바스크립트는 직접적인 메모리 제어를 허용하지 않는다.
메모리 주소를 통해 값에 직접 접근하려는 시도는 올바른 방법이 아니다.

변수 : 하나의 값을 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 (값의 위치를 가리키는 이름)
변수는 변수 이름과 변수 값으로 이루어져 있으며, 변수에 값이 할당되면 참조할 수 있게 된다.

## 4.2 식별자
식별자 :어떤 값을 구별해서 식별할 수 있는 고유한 이름 (변수, 함수, 클래스 등의 이름)
값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야한다.

## 4.3 변수 선언
[변수를 선언할 때는 var, let, const 키워드를 쓴다.]
```
var score;
```
변수를 선언하고 값을 저장하지 않았으면 => 비어있는 것이 아니라 undefined라는 원시타입의 값이 암묵적으로 할당되어 초기화된다.
즉, 선언과 초기화가 동시에 진행된다. 

ReferenceError : 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러

+) var 키워드의 단점 : 블록 레벨 스코프 지원 X (함수 레벨 스코프 지원)
+) 모든 식별자는 실행 컨텍스트(소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 관리하는 영역)

## 4.4. 변수 선언의 실행 시점과 변수 호이스팅
자바스크립트 엔진은 소스코드를 한 줄씩 실행 (인터프리터의 특징)하기에 앞서 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.
이때 모든 선언문을 먼저 실행한다!
=> 변수 호이스팅 : 변수 선언은 런타임 전 단계에서 실행된다.
```
console.log(score); // undefined
var score; // 변수 선언 -> 런타임 이전에 실행
```

## 4.5 값의 할당
변수 선언은 런타임 이전에 실행되만, 값의 할당은 런타임에 실행된다.
```
console.log(score); // undefined
var score = 80;
console.log(score); // 80
```
=> 변수의 선언과 값의 할당을 하나의 문장으로 줄여도 자바스크립트 엔진은 값의 선언과 할당을 2개로 나누어서 실행한다.
(왜냐하면 실행해야하는 시간이 다르기 때문에 어쩔 수 없음)

변수에 값을 할당할 때는 undefined가 있던 공간 대신 새로운 메모리 공간을 확보하고 그 곳에 할당값을 저장한다.
```
console.log(score); // undefined
score = 80;
var score;
console.log(score); / 80
```

## 4.6 값의 재할당
var 변수는 변수의 값을 재할당할 수 있다.
재할당 가능 : 변수, 재할당 불가능 : 상수

변수의 값을 재할당할 때도 메모리의 새로운 공간을 확보하고 그 공간에 값을 저장한다.
이렇게 되면 원래의 값은 어떤 식별자와도 연결되어 있지 않는다. => 가비지 콜렉터로 관리 (언제 해제될 지는 예측할 수 없다)

갓수진 언니의 추가 설명 : 변수를 선언을 하면 일단 주소가 지정된다. (포인터와 비슷한 개녕) 그러면 포인터가 맨처음에 메모리에 undefined가 저장되어있는 공간을 가리키는 거고,
값을 할당하게 되면 그 새로운 값이 메모리 어딘가에 저장되고 내 포인터가 그 새로운 값이 저장된 메모리를 가리키게 바뀌는 것이다.

 +) 언매니지드 언어 : 메모리 제어를 개발자가 주도, 매니지드 언어 : 개발자의 직접적인 메모리제어 허용 X

 ## 4.7 식별자 네이밍 규칙
 - 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어, 달러를 포함할 수 있다.
 - 특수문자를 제외한 문자, 언더스코어, 달러로 시작해야한다. (숫자 X)
 - 예약어는 사용할 수 없다.
 - 자바스크립트에서는 대소문자를 구별한다.
 - 네이밍 컨벤션
```
var firstName; //카멜 케이스
var fisrt_name; // 스네이크 케이스
var FirstName; // 파스칼 케이스

// 헝가리언 케이스
var strFirstName // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observalble$ = fromEvent(document, 'click'); // RxJS 옵저버블
```
가독성 높이려면 카멜 케이스(변수나 함수 이름)나 파스칼 케이스(생성자 함수, 클래스 이름) 따르는 것이 유리

# 5장 표현식과 문

## 5.1 값
값 : 값은 식이 평가되어 생성된 결과를 말한다.
변수에 할당되는 것은 값이다.
=> 따라서 변수에 저장되어야 하는 값 (10 + 20)은 할당 이전에 평가되어 값을 생성해야한다.

## 5.2 리터럴
값을 생성하는 가장 기본적인 방법 (사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법)
자바스크립트 엔진은 런타임에 리터럴을 평가해서 값을 생성한다.

## 5.3 표현식
값으로 평가될 수 있는 문
=> 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참고한다.
리터럴은 그 자체로 평가식이다.
즉, 표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다.
표현식과 표현식이 평가된 값은 동치이다.
=> 표현식은 값처럼 사용할 수 있다.

## 5.4 문
문 : 프로그램을 구성하는 기본 단위이자 최소 실행 단위
토큰 : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 (키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등)
프로그램 > 문 (할당문, 선언문, 조건문, 반복문) > 토큰

## 5.5 세미콜론과 세미콜론 자동 삽입 기능
세미콜론은 문의 종료를 나타낸다. (하지만 옵션임 -> 세미콜론 자동 삽입 기능 (ASI))
단, 0개 이상의 문을 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않는다.
(코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문이다.)
하지만 ASI의 삽입 결과를 개발자가 잘못 예측할 수 있기 때문에 세미콜론 사용을 권장하고 있다.

## 5.6 표현식인 문과 표현식이 아닌 문
구분 방법 : 표현식인 문 - 값으로 평가될 수 있는 문, 표현식이 아닌 문 - 값으로 평가될 수 없는 문
=> 변수에 할당해 보는 것으로 구분할 수 있다
```
var foo = var x; // 표현식이 아닌 문은 값처럼 사용할 수 없다.
var X = 100; // 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다
var foo = x = 100; // 표현식인 문은 값처럼 사용할 수 있다.
console.log(foo); // 100
```
크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined -> 완료값 (변수 할당, 참조 X)
표현식인 문은 언제나 평가된 값 반환
