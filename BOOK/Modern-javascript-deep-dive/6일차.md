# 11장 원시 값과 객체의 비교
원시 타입과 객체 타입의 차이 점
- 원시 값은 변경 불가능한 값 객체 값은 변경 가능한 값
- 원시값을 변수에 할당하면 변수에는 실제 값이 저장되고, 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 값에 의한 전달이 이루어지고 객체를 가리키는 변수를 다른 변수에 할당하면 참조에 의한 전달이 이루어진다.

## 11.1 원시 값
### 11.1.1 변경 불가능한 값
원시 값은 읽기 전용으로서 변경할 수 없다. => 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다.
상수는 재할당이 금지된 변수일 뿐이다.

원시 값을 재할당하면 변수가 참조하던 메모리 공간의 주소가 바뀐다.
불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

### 11.1.2 문자열과 불변성
문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 코기가 결정된다.
자바스크립트의 문자열은 원시 타입이며, 변경 불가능하다.
문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.
원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환된다.

### 11.1.3 값에 의한 전달
```
var score = 80;
var copy = score; // 새로운 숫자 값 80이 생성되어 copy 변수에 할당된다.
score === copy; // true
```
이를 값에 의한 전달이라 한다. -> score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
식별자는 값이 아니라 메모리 주소를 기억한다.
값에 의한 전달도 메모리 주소를 전달하고 메모리 주소로 공간에 접근해 값을 참조한다.

## 11.2 객체
객체는 확보해야할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
자바스크립트에서 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.
대신 프로퍼티에 접근하기 위해 동적 탐색 대신 히든 클래스 방식을 사용한다.

### 11.2.1 변경 가능한 값
원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체는 참조값(객체가 저장된 메모리 공간의 주소)에 접근하게 된다.
객체는 변경 가능하기 때문에 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고, 프로퍼티 값을 갱신, 삭제할 수 있다. => 객체가 너무 커서
이러한 특징에 의한 단점 -> 여러 개의 식별자가 하나의 객체를 공유할 수 있다.

얕은 복사, 깊은 복사로 생성된 객체는 원본과 다른 객체이다.

### 11.2.2 참조에 의한 전달
참조에 의한 전달 : 참조 값이 복사되어 전달
값에 의한 전달과 참조에 의한 전달은 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서는 동일하다 => 자바스크립트는 값에 의한 전달만 존재한다고 볼 수 있다.

# 12장 함수
## 12.1 함수란?
프로그래밍 언어의 함수는 ㅇ리련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
매개변수 : 함수 내부로 입력을 전달받는 변수
인수 : 입력
반환값 : 출력
함수 정의 -> 함수를 생성하는 것
함수 호출 -> 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는 것

## 12.2 함수를 사용하는 이유
코드의 재사용, 유지보수의 편의성, 코드의 신뢰성

## 12.3  함수 리터럴
함수도 함수 리터럴로 생성할 수 있다.
```
function add(x,y) {
  return x + y;
}
```
함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. 함수이름은 생략할 수 있다.
매개변수 목록은 순서에 의미가 있다. 매개변수는 몸체 내에서 변수와 동일하게 취급된다.
함수 몸체는 함수 호출에 의해 실행된다.
함수는 객체이지만 일반 객체와 다르다. -> 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.

## 12.4 함수 정의
- 함수 선언문
- 함수 표현식
- Fuction 생성자 함수
- 화살표 함수
```
function add(x,y) {
  return x + y;
} // 선언문

var add = function (x,y) {
  return x + y;
}; // 함수 표현식

var add = new Function('x', 'y', 'return x + y'); // Function 생성자 함수

var add = (x, y) => x + y; // 화살표 함수
```
### 12.4.1 함수 선언문
함수 리터럴과 형태가 동일하다. 단 함수 리터럴과 다르게 함수 이름을 생략할 수 없다.
함수 선언문은 표현식이 아닌 문이다. => 개발자 도구에서 실행 시 완료값 undefined가 출력된다.
따라서 변수에 할당할 수 없다.
```
// 함수 선언문이 변수에 할당되는 것 처럼 보인다.
var add = function add(x, y) {
  return x + y;
};
```
이렇게 동작하는 이유 -> 함수 선언문으로 해석될 수도, 함수 리터럴 표현식으로 해석될 수도 있어서
함수 선언문 : 표현식이 아닌 문
함수 리터럴 : 표현식인 문
문맥에 따라 해석이 달라진다 : {}도 마찬가지 -> 블록문 or 객체 리터럴

함수 리터럴 단독 사용 : 함수 선언문
함수 리터럴 변수에 할당 or 피연산자로 사용 : 함수 리터럴 표현식

함수 리터럴 사용시 주의 : 함수 몸체 외부에서는 함수 이름으로 함술를 참조할 수 없으므로 함수 이름으로 함수를 호출할 수 없다.
근데 함수 선언문으로 생성된 함수 이름은 사용 가능하다.
```
function foo() {console.log('foo');}
foo(); // foo
(function bar() {console.log('bar');});
bar(); -> ReferenceError: bar is not defined
```
bar는 안되는데 foo는 되는 이유 : foo는 자바스크립트 엔진이 암묵적으로 생성한 식별자여서
```
var f = function add(x,y){
  return x + y;
};

console.log(f(2, 3)); // 5 출력
console.log(add(2, 3)); // ReferenceError: add is not defined
```

즉, 함수 선언문은 식별자를 자동으로 생성해주지만, 함수 리터럴은 식별자를 생성해주지 않는다.
함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있다.

### 12.4.2 함수 표현식
일급 객체 : 값의 성질을 갖는 객체
