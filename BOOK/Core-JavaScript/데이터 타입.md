## 01. 데이터 타입의 종류
- 자바스크립트의 데이터 타입 종류 : 기본형, 참조형
![image](https://github.com/user-attachments/assets/3df57a68-8609-4a21-a9f0-6b2949c249b8)
  - 기본형과 참조형 구분 기준
    - 할당이나 연산 시 기본형은 복제되고, 참조형은 참조된다.
    - 기본형은 값이 담긴 주솟값을 바로 복제하고 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.
    - 기본형은 불변성을 띈다.

## 02. 데이터 타입에 관한 배경지식
- 1 바이트는 8개의 비트로 구성된다.
- 자바스크립트는 숫자의 경우 정수형인지 부동소수형인지를 구분하지 않고 8 바이트를 확보한다.
- 모든 데이터는 바이트 단위의 식별자 (메모리 주솟값)을 통해 서로를 구분하고 연결할 수 있다.

#### 식별자와 변수
- 변수 : 변할 수 있는 데이터 (숫자, 문자열, 객체, 배열 등)
- 식별자 : 어떤 데이터를 식별하는데 사용하는 이름, 즉 변수명

## 03. 변수 선언과 데이터 할당
#### 변수 선언
```
var a;
```
- 변할 수 있는 데이터를 만들고, 이 데이터의 식별자는 a로 한다. <br>
-> <b>변수 : 변경 가능한 데이터가 담길 수 있는 공간</b>

- 위의 선언식을 명령으로 받아서 컴퓨터가 수행하는 작업
  - 메모리에서 비어있는 공간 하나 확보
  - 이 공간의 이름(식별자)를 a라고 지정
  - 이후에 사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해서 해당 공간에 담긴 데이터를 반환

#### 데이터 할당
```
var a; // 변수 a 선언
a = 'abc'; // 변수 a에 데이터 할당

var a = 'abc'; // 변수 선언과 할당을 한 문장으로 표현
```
- 두 가지 방법의 데이터 할당 모두 자바스크립트 엔진 내에서 같은 동작을 수행한다.
- a라는 이름을 가진 주소에 문자열 abc 저장하는 게 아니다.
- 데이터를 저장하기 위한 별도의 메모리 공간을 새로 확보해 문자열 'abc'를 저장하고,
- 그 주소를 변수 영역에 저장한다. <br>
-> <b>이러한 저장 방식의 장점 : 데이터 변환 효율, 메모리 관리 효율</b>

##### 효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.
문자열 'abc'의 뒤에 'def'를 추가하려고 한다면?
- 'abcdedf'라는 문자열을 새로 만들어서 별도의 공간에 저장하고 그 주소를 변수 공간에 연결한다.
- 기존 문자열에 어떤 변환을 가하든 상관 없이 무조건 새로 만들어서 별도의 공간에 저장한다.

500개의 변수를 생성해서 모든 변수에 숫자 5를 할당한다면?
- 5를 별도의 공간에 한 번만 저장하고 해당 주소만 입력하면 데이터에 대한 처리 효율이 높아진다.

## 04. 기본형 데이터와 참조형 데이터
#### 불변값
변수와 상수의 구분 기준
- 한 번 데이터 할당이 이루어진 변수 공간에 다른 데이터를 재할당할 수 있는지
불변성 여부의 구분 기준
- 데이터 영역 메모리의 변경 가능성
##### 변경은 새로 만드는 동작을 통해서만 이루어진다. -> 불변값의 성질, 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.
-------
#### 가변값
참조형 데이터의 기본적인 성질은 가변값이지만 설정에 따라 변경 불가능한 경우도 있고 아예 불변값으로 활용하는 방안도 있다.
```
var obj1 = {
  a: 1,
  b: 'bbb',
};
obj1.a = 2;
```
- 객체의 변수 영역이 별도로 존재한다.
- 데이터 영역에 저장된 값은 모두 불변값이다.
- 하지만 객체의 변수에는 다른 값을 얼마든지 대입할 수 있다. <br>
-> 새로운 객체가 만들어지는 게 아니라 기존 객체 내부의 값만 바뀐다.

참조 카운트 : 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수 <br>
참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다.

#### 변수 복사 비교
```
var a = 10;
var b = a;

var obj1 = {c:10, d: 'ddd'};
var obj2 = obj1;
```
- 변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다.

```
var a = 10;
var b = a;
var obj1 = {c:10, d: 'ddd'};
var obj2 = obj1;

b = 15;
obj2.c = 20;
```
- 변수 복사 이후 값 변경 결과 비교
- 기본형
  - 두 변수가 서로 다른 주소를 바라보게 된다.
- 참조형
  - 두 변수가 여전히 서로 같은 주소(객체)를 바라본다.
```
a!==b
obj1 === obj2
```

##### 즉, 자바스크립트의 모든 데이터 타입은 참조형 데이터이다.
##### 다만 기본형은 주솟값을 복사하는 과정이 한 번만 이루어지고, 참조형은 한 단계를 더 거치게 된다.

```
var a = 10;
var b = a;
var obj1 = {c:10, d: 'ddd'};
var obj2 = obj1;

b = 15;
obj2.c = {c:20, d:'ddd'};
```
- 참조형의 객체 프로퍼티를 바꾸는 게 아니라 객체 자체를 변경하는 경우
- 기본형과 같이 바라보는 주소가 달라진다.
##### 즉, 참조형 데이터가 가변값이라고 설명할 때의 가변은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.

## 05. 불변 객체
- 그렇다면 내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구를 활용하면 객체도 불변성을 확보할 수 있을 것이다.

  - 불변 객체가 필요한 경우
    - 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우
    ```
    var user = {
      name: 'Jaenam',
      gender: 'male'
    };

    var changeName = function(user, newName) {
      var newUser = user;
      newUser.name = newName;
      return newUser;
    };

    var user2 = changeName(user, 'Jung');

    console.log(user.name, user2.name); // Jung Jung
    console.log(user === user2); // true
    ```
    - 위의 문제를 해결하기
      - 객체의 기존 정보를 복사해서 새로운 객체를 반환하는 함수 (얕은 복사)
        ```
        var copyObject = function(target) {
          var result = {};
          for (var prop in target) {
            result[prop] = target[prop];
          }
          return result;
        };
        ```
        -> 협업하는 모든 개발자들이 user 객체 내부의 변경이 필요할 때는 무조건 copyObject 함수를 사용하기로 합의하고 그 규칙을 지키면 user 객체는 불변 객체이다.

#### 얕은 복사와 깊은 복사
얕은 복사는 바로 아래 단계의 값만 복사하는 방법, 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법
- 얕은 복사 : 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 되고, 사본을 바꾸면 원본이 바뀌고, 원본을 바꾸면 사본도 바뀐다.
- 중첩된 객체에 대한 깊은 복사
```
var user2 = copyObject(user);
user2.urls = copyObject(user.urls);
```
-> 깊은 복사 : 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야한다. <br>

copyObject 함수를 깊은 복사 방식으로 고친 코드
```
var copyObjectDeep = function(target) {
  var result = {};
  if (typeof target === 'object' && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }
  return result;
};
```
-> 재귀를 이용해서 깊은 복사 구현, 이제 원본과 사본이 서로 영향을 주지 않게 된다. <br>
+) 간단하게 구현하는 깊은 복사 : 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸기 <br>
하지만 JSON으로 바꿀수 없는 프로퍼티들은 무시된다.
```
var copyObjectViaJson = function(target) {
  return JSON.parse(JSON.stringify(target));
};
```

## 06. undefined와 null
- undefined
  - 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여한다.
    - 사용자가 어떤 값을 지정할 것이라고 예상되는 상황인데 그렇지 않을 때
      1. 값을 대입하지 않은 변수에 접근할 때
      2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
      3. return 문이 없거나 호출되지 않는 함수의 실행 결과
    - undefined와 배열
      - 배열에 n개의 빈 요소를 확보했지만 확보된 각 요소에 undefined조차도 할당되지않을 수도 있다.
      - 비어있는 요소 (empty)와 undefined를 할당한 요소는 차이가 있다.
      - 비어있는 요소는 배열 메서드들의 순회 대상에서 제외된다.
      - 배열도 객체이기 때문에 값이 지정되지 않은 인덱스는 아직 존재하지 않는 프로퍼티이다.
    - 값으로 할당된 undefined는 실존하는 데이터이지만, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타낸다.
    - 혼란을 막기 위해서 undefined를 직접할당하는 것을 지양하자.
- null
  - 비어있음을 명시적으로 나타내고 싶을 때 쓰기
  - typeof : object
- 동등연산자로는 null과 undefined를 구분할 수 없다. 따라서 일치 연산자를 써야한다.
