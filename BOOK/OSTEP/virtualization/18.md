# 21. 페이징: 개요
공간 관리 문제를 해결하기 위해서 공간을 동일 크기의 조각으로 분할하는 것 : 페이징
프로세스의 주소 공간을 몇 개의 가변 크기의 논리 세그멘트 (코드, 힙, 스택)으로 나누는 것이 아니라 고정 크기의 단위로 나눈다.
-> 이 단위가 페이지이다.
이에 상응해서 물리 메모리도 페이지 프레임이라고 불리는 고정 크기의 슬롯의 배열이라고 생각하면 프레임 각각은 하나의 가상 메모리 페이지를 저장할 수 있다.

# 21.1 간단한 예제 및 개요
페이징 방식의 장점 : 효율적으로 주소 공간 개념을 지원할 수 있다. (유연성) + 빈 공간 관리의 단순성
페이지 테이블 : 가상 페이지에 대한 물리 메모리 위치 기록 자료구조 (주소 변환 정보를 저장한다.) (각 페이지가 저장된 물리 메모리의 위치가 어디인지 알려준다.)

# 21.2 페이지 테이블은 어디에 저장되는가
페이지 테이블이 매우 크기 때문에 현재 실행 중인 프로세스의 페이지 테이블을 저장할 수 있는 회로를 MMU 안에 유지하지 않고 대신 각 프로세스의 페이지 테이블을 메모리에 저장한다.
또한 디스크에 스왑될 수 있다.

# 21.3 페이지 테이블에는 실제 무엇이 있는가
페이지 테이블은 가상주소를 물리 주소로 매핑하는 데 사용되는 자료구조이다. 
선형 페이지 테이블 : 가장 간단한 형태 - 원하는 물리 프레임 번호를 찾기 위해 가상 페이지 번호로 배열의 항목에 접근하고 그 항목의 페이지 테이블 항목을 검색한다.

운영체제는 원하는 물리 프레임 번호를 찾기 위해서 가상 페이지 번호로 배열의 항목에 접근하고 그 항목의 페이지 테이블 항목을 검색한다.
페이지 테이블에 존재하는 다양한 비트
- valid bit : 특정 변환의 유효 여부를 나타내기 위하여 포함 (할당되지 않은 주소 공간을 표현하기 위해서 반드시 필요하다.)
- protection bit : 페이지가 읽을 수 있는지, 쓸 수 있는지, 실행될 수 있는지를 표시
- present bit : 이 페이지가 물리 메모리에 있는지 혹은 디스크에 있는지 가리킨다.
- dirty bit : 메모리에 반입된 후 페이지가 변경되었는지 여부를 나타낸다.
- reference bit (accessed bit) : 페이지가 접근되었는지를 추적하기 위해 사용된다.

# 21.4 페이징: 너무 느림
페이지 테이블로 인해 처리 속도가 저하될 수 있다.
모든 메모리 참조에 대해서 먼저 페이지 테이블에서 변환 정보를 반입해야하기 때문에 반드시 한 번의 추가적인 메모리 참조가 필요하다. 
메모리 참조는 비용이 비싸고 이 경우에 프로세스는 2배 이상 느려진다.

# 21.5 메모리 트레이스
프로그램이 실행되면 각 명령어의 반입 시에 메모리가 두 번 참조한다. (명령어의 위치를 파악하기 위해 페이지 테이블 접근 한 번 그리고 명령어 자체에 한 번)
