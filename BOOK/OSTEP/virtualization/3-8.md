# 3. 가상화에 관한 대화
복숭아를 먹고 싶은 사람들이 낮잠 자거나 다른 일을 하고 있는 시간에 복숭아를 낚아채서 다른 사람에게 주는 것. 이렇게 해서 여러 개의 가상 복숭아가 있다는 환상, 사람마다 복숭아를 하나씩 가지고 있다는 환상을 만들어 내는것.
os와 관련짓는다면 -> 1개 뿐인 cpu를 각 응용 프로그램이 자신만 사용하는 cpu를 가지게 되었다고 생각하게 만드는 것.

# 4. 프로세스
## 프로세스의 개념
프로세스 : 실행 중인 프로그램

운영체제는 cpu를 가상화해서 무한개에 가까운 cpu가 있다는 환상을 만들어낸다.

시분할 : 컴퓨터 시스템의 자원을 여러 사용자나 작업이 일정한 시간 단위로 공유하는 방식, CPU를 공유하기 때문에 프로세스의 성능은 낮아진다.
시분할 시스템은 주로 라운드 로빈 스케줄링 방식을 사용해서 작업을 처리한다.
(공간분할) : 디스크 분할하는 거
라운드로빈 스케줄링 : 각 작업에 동일한 시간을 할당하고, 첫 번째 작업이 주어진 시간 동안 실행한 후 다음 작업이 시작된다. 모든 작업이 처리된 후 다시 처음 작업으로 돌아가서 반복한다.

메커니즘 : 필요한 기능을 구현하는 방법이나 규칙
정책 : 운영체제 내에서 어떤 결정을 내리기 위한 알고리즘

프로세스를 간단하게 표현하려면 실행되는 동안 접근하거나 영향을 받은 자원의 목록을 작성하면 된다. 왜냐하면 프로세스의 구성 요소를 이해하기 위해서는 하드웨어 상태를 이해해야하기 때문이다.
이때 가장 중요한 하드웨어 구성요소는 메모리이다.
왜냐하면 명령어, 데이터 등이 메모리에 저장되기 때문이다.
레지스터도 중요하다. 
그 중에서 더 중요한 레지스터들
- 프로그램 카운터 (PC) : 컴퓨터 프로세서 내에서 실행될 다음 명령어의 메모리 주소를 저장하는 레지스터, 현재 어떤 명령어 실행하고 있는지 다음에 실행할 명령어가 어디에 있는지를 추적하는 중요한 역할
- 스택 포인터 : 스택 메모리의 최상단 위치를 가리키는 레지스터 스택 메모리에 데이터를 저장하거나 꺼내올 위치를 추적한다. (새로운 스택 프레임의 시작 위치)
- 프레임 포인터 : 함수 호출 시 기준이 되는 스택 프레임의 시작 지점을 가리킨다. 함수의 스택 프레임이 일정하게 유지되도록 도와준다. 스택 프레임의 시작 지점을 가리키는 레지스터

기법 : 어떻게라는 질문에 답을 제공하는 것
정책 : 어느것이라는 질문에 답을 제공

## 프로세스 API

반드시 api로 제공해야하는 몇몇 기본 기능
- 생성 : 새로운 프로세스를 생성할 수 있는 방법을 제공해야한다.
- 제거 : 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야 한다.
- 대기 : 때로는 어떤 프로세스의 실행 중지를 기다릴 필요가 있다.
- 각종 제어 : 프로세스의 제거, 대기 외에 여러가지 제어 기능이 제공된다. (ex: 일시정지)
- 상태 : 프로세스 상태 정보 얻어내는 인터페이스

## 프로세스 생성 
1. 프로그램 코드와 정적 데이터를 메모리, 프로세스의 주소 공간에 load한다. (코드와 정적 데이터를 메모리에 탑재하기 위해서 운영체제는 디스크의 해당 바이트를 읽어서 메모리 어딘가에 저장해야한다.)
 초기 운영체제들은 프로그램 실행 전 이 과정을 다 했지만, 요즘은 필요할 때 필요한 부분만 메모리 탑재 -> 페이징과 스와핑 동작의 이해 필요
2. 일정량의 메모리가 프로그램의 실행시간 스택 용도로 할당되어야한다. (스택을 초기화해줘야한다.)
3. 힙을 위한 메모리 영역을 할당한다. (힙은 크기가 가변적인 자료 구조를 위해 사용된다.)
4. 입출력 관련 초기화 작업을 수행한다.
5. 프로그램 실행을 위한 준비 끝! -> main()에서부터 프로그램을 실행
6. 운영체제는 CPU를 새로 생성된 프로세스에게 넘기게 되고 프로그램 실행이 시작된다.

페이징 : 프로세스의 메모리를 고정된 크기의 블록으로 나누어 물리 메모리의 비연속적인 공간을 사용할 수 있게 해주는 기술 -> 가상 메모리는 연속적인 주소를 가진다.
스와핑 : 메모리와 디스크 사이에서 프로세스를 통째로 이동시키는 과정, 메모리 부족하면 프로세스를 메모리에서 디스크로 내보내고 필요할 때 다시 메모리로 불러온다.

## 프로세스 상태
- 실행 : 프로세스는 명령어를 실행하고 있다.
- 준비 : 프로세스는 실행할 준비 완료, 운영체제가 다른 프로세스를 실행하는 등의 이유로 대기
- 대기 : 프로세스가 다른 사건 기다리는 동안 프로세스의 수행을 중단시키는 연산

프로세스는 운영체제의 스케줄링 정책에 따라 스케줄이 되면 준비 상태에서 실행 상태로 전이한다.
실행 -> 준비 : 나중에 다시 스케줄 될 수 있는 상태가 되었다.

## 자료 구조
운영체제도 프로그램이기 때문에 다양한 정보를 유지하기 위한 자료 구조를 가지고 있다.
ex) 프로세스 리스트 : 준비 상태의 프로세스 관리, 레지스터 문맥 : 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장

실행, 준비, 대기 외의 다른 상태들 : 초기 상태 (프로세스가 생성되는 동안), 최종 상태 ( 프로세스는 종료되었지만 메모리에 남아있음)

# 5. 프로세스 API
unix는 프로세스를 생성하기 위하여 fork()와 exec() 시스템 콜을 사용한다.
wait()는 프로세스가 자신이 생성한 프로세스가 종료되기를 기다리기 원할 때 사용한다.

## fork() 시스템 콜
프로세스 생성에 fork() 시스템 콜이 사용된다.
fork()로 생성된 프로세스는 호출한 프로세스의 복사본이다.

PID : 프로세스 식별자
