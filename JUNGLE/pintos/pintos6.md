# Project3 OVERVIEW
- 물리 메모리는 한정되어 있지만, 많은 프로세스들은 물리 메모리를 사용하고 싶어하고 물리 메모리는 모든 프로세스의 페이지가 사용할 만큼 크지 않다.
- 만약에 페이지가 물리 메모리를 필요로 하지 않으면 페이지 아웃된다.
  - 페이지 아웃 : 물리적 메모리의 공간이 부족할 때 사용하지 않는 메모리 페이지를 하드 디스크의 스왑 공간으로 내보내는 작업
  - 최근에 사용하지 않았거나 덜 중요한 페이지를 선택해서 스왑 공간으로 내보낸다. (어떤 페이지가 안 중요하냐의 기준: 페이지 교체 알고리즘)
  - 스왑 공간 : 디스크의 일부를 사용해서 임시로 데이터를 보관하는 공
- 프로세스가 페이지를 필요로하고 물리 메모리에 없을 때. 페이지 인 되어야 한다.
  - 페이지 인 : 페이지 아웃되었었던 페이지가 다시 필요해지면 해당 페이지를 스왑 영역에서 물리적 메모리로 불러오는 과정 이 과정에서 페이지 폴트가 발생해서 시스템이 페이지를 다시 읽어오게 된다.
  - 페이지 폴트 : 프로그램이 메모리에 있는 데이터를 읽으려고 했는데 그 페이지가 페이지 아웃되어서 메모리에 없기 때문에 페이지 폴트가 발생함. 그러면 운영체제가 해당 페이지를 다시 메모리로 로드한다.

to do
--------
- supplemental page table (SPT) : 페이지 테이블 보충 자료 구조, 페이지가 파일에서 로드되었는지 스왑 영역에서 관리되는지 등을 추적
- 물리적 프레임 관리 : 물리 메모리의 개별 블록 (페이지)
- 페이지 폴트 핸들러 수정 (lazy loading) : 메모리 페이지를 프로그램이 실제로 필요할 때까지 로드하지 않는 방법
  - 페이지 폴트가 발생하면 그때 파일에서 읽어오거나 스왑에서 가져오는 방식으로 메모리를 로드하도록 수정 (stack growth, file-mapped memory 등)
    - stack growth : 프로그램이 더 많은 스택 메모리를 필요로 하면, 페이지 폴트가 발생하면서 스택 영역이 커지게 된다.
    - file-mapped Memory : 파일의 내용을 메모리에 매핑해서 직접 읽거나 쓸 수 있도록 하는 기술, 큰 파일을 열었을 때 한 번에 모두 메모리에 로드하는 대신 필요한 부분만 메모리에 로드하는 방식으로 처리 (이때도 페이지 폴트 발생)
- mmap, munmap : 파일을 메모리에 매핑하여 파일 내용을 직접 메모리에서 읽거나 쓸 수 있게해주는 시스템 콜과 메모리에 매핑한 파일을 해제해주는 함수
- swap in/out : 페이지를 스왑 영역에 저장했다가 가져오는 과정

Terminology
-----------
페이지 : 가상 메모리에서 연속된 메모리 영역, 프로그램이 사용하는 주소 공간을 작은 단위로 나눈 것
프레임 : 물리 메모리에서 연속된 메모리 영역, 페이지가 실제로 로드될 수 있는 메모리 블록 (페이지가 프레임에 매핑된다)
페이지 테이블 : 가상 주소를 물리 주소로 변환하기 위한 데이터 구조 (페이지를 프레임에 매핑하는 역할)
Eviction (페이지 교체) : 프레임(메모리)에서 페이지를 제거하는 과정 페이지를 스왑 테이블이나 파일 시스템에 저장한다. (메모리가 부족할 때 주로 발생한다.)
스왑 테이블 : 프레임에서 제거된 페이지가 기록되는 공간 스왑 파티션에 위치하며 나중에 페이지를 다시 로드할 때 사용된다.

+ 파일이 메모리에 매핑된다?
  - 파일의 내용을 메모리 주소 공간에 직접 연결해서 프로세스가 파일 데이터를 메모리에 있는 것 처럼 읽고 쓸 수 있도록 하는 과정 (mmap으로 구현한다)
  
자료구조 구현할 때 포함 할 내용
---------------
1. SPT : 각 프로세스마다 가상 메모리 페이지의 추가 정보를 관리 (페이지의 데이터가 위치하는 곳 -ex: 스왑공간, 디스크 등, 해당 페이지가 매핑된 커널 가상 주소에 대한 포인터, 페이지의 활성 상태 등)
2. 프레임 테이블 : 물리 메모리의 프레임을 추적하는 전역적인 데이터 구조, 할당 가능한 프레임이랑 비어있는 프레임 기록하고 각 프레임이 어느 프로세스의 어느 페이지랑 연결 되어있는지도 저장)
3. 스왑 테이블 : 스왑 공간에서의 페이지 위치를 추적하는 구조, 스왑 아웃된 페이지 스왑 인 할 때, 스왑 테이블을 통해 페이지의 위치를 찾아 로드
4. 파일 매핑 테이블 : 파일이 메모리에 매핑된 상태를 추적하는 데이터 구조, 어떤 파일이 어떤 가상 페이지에 매핑되어 있는지 

Lazy loading
---------------
1. 가상 주소 생성 : 프로세스가 메모리 매핑을 수행할 때 (mmap) 핀토스는 해당 가상 주소에 struct page를 연결한다. 이 구조체는 가상 주소에 대한 정보를 담고 있다.
2. 다양한 메모리 용도 : 각 가상 주소는 다양한 용도로 사용된다.
    - 익명 메모리 : 파일과 연결되지 않은 메모리로 프로세스의 동적 데이터에 사용된다.
    - 파일 지원 메모리 : 특정 파일에 연결된 메모리로 파일의 내용을 포함한다.
3. struct page : 각 struct page는 여러가지 정보를 포함하고 있다. (해당 가상 주소와 연관된 메모리의 상태, 페이지의 위치, 해당 페이지에 대한 커널 가상 주소 등)
4. 물리 프레임 할당 : struct page를 할당한다고 해서 가상 주소에 물리 프레임이 즉시 할당되는 것은 아니고 페이지 폴트가 발생할 때 할당 된다.

struct page and page_operations
------------
페이지는 맨 처음에 할당되었지만 초기화 되지 않은 uninit_page 상태에서 시작한다.
따라서 anon_initializer, file_map_initializer 등 페이지 유형에 따라 적절한 초기화 함수를 연결해주어야 한다.

supplemental page table
------------
페이지 테이블을 직접 변경하지 않는 이유 : 페이지 테이블은 기본적인 주소 변환 정보를 제공하는 데중점을 두고, 성능에도 영향을 줄 수 있기 때문에 spt를 사용하는 것이 더 낫다.

spt_find_page: 주어진 가상 주소에 대해 spt에서 해당 페이지를 찾는 함수
spt의 주요 목적
1. 페이지 폴트 처리 : 커널이 spt에서 가상 페이지를 조회해서 어떤 데이터가 있어야 하는지, 또는 어디에 데이터가 있어야 하는지를 확인한다.
2. 프로세스 종료시 자원 해제 : 프로세스가 종료될 때 커널은 spt를 조회해서 어떤 자원을 해제해야하는지를 결정한다.

Frame Table
------------
물리적 메모리의 프레임을 관리하는 데이터 구조 (각 프레임의 상태를 추적함)
1. 프레임이 가득 차 있지 않을 때 : 그냥 페이지를 비어있는 새로운 프레임에 할당하면 된다.
2. 프레임이 가득 차 있을 때 : 프레임 테이블을 이용해서 교체를 해주자

이때 페이지 교체 알고리즘은 LRU를 근사하여 동작해야하며 clock 알고리즘 보다 성능이 우수해야한다. 
vm_get_victim : 어떤 페이지를 교체할 지 결정하는 역할 - 주의사항 사용자 페이지만 관리한다.

페이지 교체 과정
1. 페이지 교체 알고리즘으로 교체할 프레임 선택
2. 해당 프레임에 대한 페이지 테이블 참조 제거 (다중 참조 -> extra credit)
3. 필요한 경우 페이지를 파일 시스템이나 스왑에 기록하기
비트 활용: CPU에 의해 설정된 accessed 비트와 dirty 비트를 통해 페이지 교체 결정 및 데이터 저장 여부를 관리.

swap table
-----------
1. 스왑 슬롯의 상태 추적 (사용중 or 비사용중)
2. 페이지를 스왑 파티션으로 옮기기 위해 비어 있는 스왑 슬롯 선택
  - 페이지가 물리 메모리에서 제거될 때 스왑 테이블을 사용해서 사용 가능한 스왑 슬롯을 선택한다.
3. 페이지가 다시 메모리로 읽혀지거나 프로세스가 종료될 때 스왑 슬롯을 해제한다.

스왑 슬롯이 꽉차면? 페이지를 스왑 공간으로 이동시킬 수 없다. 이로 인해 페이지 폴트가 발생한다.

stack Growth
------------
1. 프로젝트 2 : 프로세스가 생성될 때 일정한 양의 스택 공간을 미리 할당
2. 프로젝트 3 : 프로세스가 실행되는 동안 스택 공간이 부족해지면 동적으로 추가 페이지를 할당

- 스텍에 대한 유효한 접근이 이루어질 때 페이지 폴트가 발생할 수 있다.  (프로세스가 스택의 특정 위치에 접근하려고 할 때 해당 페이지가 메모리에 존재하지 않으면 페이지 폴트가 발생)
- 페이지 폴트 핸들러에서 페이지 할당
  - 유효한 스택으로의 접근에 의해 페이지 폴트가 발생한 거면 새로운 페이지를 할당한다. 페이지 폴트 핸들러에 전달된 struct intr_frame에서 %rsp 레지스터 값을 가져온다. %rsp는 현재 스택 포인터를 가리키며, 새로운 페이지를 할당할 때 이 값을 사용하여 스택의 현재 위치를 결정한다.

synchronization
---------------
여러 스레드가 동시에 프레임 테이블, 스왑 테이블 등에 접근하게 되면 데이터의 일관성이 깨질 수 있기 때문에 동기화를 주의하자

Memory Mapped Files
------------------
- mmap, munmap 사용하기
- 메모리 맵 파일의 동작 : 메모리 맵 페이지는 필요할 때 디스크에서 메모리로 로드된다. 즉 프로세스가 실제로 해당 페이지에 접근할 때 까지 디스크에서 읽지 않는다.
- mmap() 오류 리턴하는 케이스 : 파일 크기가 0 바이트인 경우, 이미 매핑된 페이지와 겹치는 파일을 매핑하려고 할 때, addr 인자가 페이지 경계에 맞지 않는 경우
- mmap된 페이지가 교체될 때 변경된 내용을 원래 파일에 다시 저장해주기
- 프로세스가 종료되면 모든 매핑이 자동으로 언매핑되어야한다.

Where to page out/evict to?
---------------------------
페이지 아웃 대상에 따라 어디로 페이지 아웃 될지가 달라진다. 
1. 사용자 스택 페이지
   - 메모리 공간에서 스왑 공간으로 페이지 아웃된다.
2. 파일 페이지
   - 메모리 매핑된 파일은 페이지 아웃될 때 파일 시스템으로 이동한다.
   - 이 때 페이지가 수정된 경우는 파일 시스템 변경 내용을 기록해야한다
   - 페이지가 수정되지 않았으면 단순히 메모리에서 해제할 수 있다. (파일 시스템으로 이동하지 않는다)
  
추천 구현 순서
--------------
1. Frame Table: 프레임 테이블을 먼저 구현하세요. 이 단계에서 스와핑은 구현하지 않아도 됩니다. 프로젝트 2의 모든 테스트를 통과할 수 있어야 합니다. 프레임 테이블은 물리적 메모리의 프레임을 관리하는 구조로, 할당된 프레임과 여유 프레임을 추적합니다.

2. Supplemental Page Table 및 Page Fault Handler: 보조 페이지 테이블을 구현하고 페이지 폴트 핸들러를 통해 코드 및 데이터 세그먼트를 지연 로드합니다. 이 단계에서는 프로젝트 2의 모든 기능 테스트를 통과해야 하지만, 일부 강인성 테스트만 통과할 수 있습니다. 보조 페이지 테이블은 각 페이지에 대한 추가 정보를 저장하는 구조입니다.

3. Stack Growth, Mapped Files, Page Reclamation: 스택의 동적 확장, 메모리 매핑된 파일 처리 및 페이지 회수 기능을 구현합니다. 이 단계에서는 스택이 필요에 따라 페이지를 동적으로 추가할 수 있도록 하고, mmap()을 통해 메모리 매핑된 파일을 처리하는 기능을 추가합니다.

4. Eviction: 마지막으로 페이지를 제거하는 기능을 구현합니다. 이 단계에서는 스와핑과 관련된 동기화를 잊지 않아야 합니다. 페이지 대체 알고리즘을 구현하고, 페이지가 프레임에서 제거될 때 적절하게 처리되도록 합니다.

-> pintos lab3 pdf 정리 끗!

# 무한한 메모리의 환상
운영체제와 하드웨어가 협력해서 메모리가 무한한 것처럼 보이게 하는 환상을 제공하는 것
물리적 메모리가 한정되어 있어도, 가상 메모리 시스템을 통해서 프로그램이 필요로하는 메모리가 물리적 메모리를 초과해도 처리할 수 있게 된다.
: 페이지 아웃, 페이지 인을 통해 구현 -> 효율적이고 메모리 확장적이지만 디스크 접근 속도는 메모리보다 훨씬 느리기 때문에 성능이 크게 저하된다. (스레싱) (디스크 I/O 증가)

# 페이지 교체 알고리즘
FIFO : 가장 오래된 페이지를 페이지 아웃
LRU : 가장 최근에 사용되지 않은 페이지를 페이지 아웃
LFU : 사용 빈도가 가장 적은 페이지를 페이지 아웃

# 자료 구조
Arrays:
List:
Bitmaps:
Hash Tables:
