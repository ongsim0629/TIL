# File system
유저 프로그램은 파일 시스템에서 불러온다.

핀토스에서 실행할 수 있는 C 프로그램 : 메모리 사이즈에 알 맞게 들어가고, 우리가 만든 (만들) 시스템 콜에 대해서만 동작한다.
이 중 어떠한 시스템 콜도 메모리 할당을 요구하지 않는다.

유저 가상 메모리 범위 : 0 ~ KERN_BASE (0x8004000000) -> 프로세스 마다 존재하며, 컨텍스트 스위치가 발생하면 가상 메모리 주소 영역도 스위치 되어야한다.
커널 가상 메모리 범위 : KERN_BASE ~ -> 전역이며, 물리 메모리와 일대일 대응된다.

## 물리 메모리와 커널 가상 메모리의 매핑
KERN_BASE : 물리 메모리 0
KERN_BASE + 0x1234 : 물리 주소 0x1234

## 접근
커널 스레드 : 케널 가상 메모리 + 사용자 가상 메모리 (running 중인 프로세스의 가상 메모리) : 하지만 매핑 되지 않은 사용자 가상 주소는 접근할 수 없다.
사용자 프로그램 : 사용자 가상 메모리만!!

## Calling Convention
함수 인자 : %rdi, %rsi, %rdx, %rcx, %r8, %r9로 전달하고 그 이상의 인자가 들어오면 스택으로 들어간다.
반환값 : %rax로 전달

구조체 인자가 하나의 word 크기보다 작다면 : 단일 레지스터 안에 들어간다.
구조체 2 ~ 4 word 크기에 해당한다면 : 여러 인자인 것 처럼 연속된 레지스터에 들어간다.
32 바이트 이상 크기에 해당한다면 : 스택에 들어간다.

# Process_exec()
유저가 입력한 명령어를 수행할 수 있도록 프로그램을 메모리에 적재하고 실행하는 함수
새로운 프로세스에 대한 인자 passing을 구현하는 것이 과제.
스페이스가 올 때 마다 단어를 파싱하도록 해야한다. 첫 번째는 프로그램 이름, 그 이후는 인자이다.
-> 문자열을 토큰으로 분리
유의점 : 여러 개의 스페이스 입력도 하나의 스페이스 입력과 동일하게 취급해야하고, 명령어 인자의 길이에 제한을 둘 수 있다.

## 인터럽트 프레임 (struct Intr_frame)
인터럽트가 들어왔을 때 기존 작업 정보를 (레지스터 값 포함)을 저장하기 위한 구조
do_iret() : 기존의 작업 context를 intr_frame에 담는 과정

## 주소공간
실행 중인 프로그램이 가정하는 메모리의 모습
하나의 주소 공간에는 실행 프로그램의 모든 메모리 상태를 가지고 있다.
프로그램 코드는 정적이기 때문에 저장하기 쉬워서 주소 공간의 상단에 배치된다.
그 아래로는 동적으로 확장 축소될 수 있는 두 종류의 주소 공간을 위치한다 (스택, 힙)

## 주소 변환
가상 주소를 실제 존재하는 물리 주소로 변환하는 과정
운영체제는 이 기능을 위해서 메모리의 빈 공간과 사용 중인 공간을 알아둬야하고 메모리 사용을 제어, 관리 해야한다.
* 각 프로세스 및 커널은 물리 메모리의 다른 영역을 참조하는 동일한 주소를 가질 수 있기 때문에 즉시 메모리를 공유할 수 없다 *

# 페이지 테이블
주소 공간의 가상 페이지에 대한 물리 메모리 위치를 기록하기 위해서 운영체제가 각 프로세스마다 페이지 테이블이라는 자료구조를 유지한다.
