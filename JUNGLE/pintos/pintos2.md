# 과제 설명서 정리
## APPENDIX
### Memory Allocation
#### 페이지 단위 메모리 할당기
페이지 단위로 메모리를 할당한다. 한 번에 한 페이지를 할당할 떄 많이 사용된다.
하지만 연속된 여러 페이지 할당할 때도 사용할 수 있다.
할당하게될 메모리를 커널 풀과 유저 풀로 나눈다. (기본적으로는 반절로 나누지만, 커널 커맨드 옵션 ul로 변경할 수 있다.)
유저풀 : 유저프로세스를 위해 메모리를 할당할 때 사용
커널풀 : 그외의 할당이 이루어질 때 사용
프로젝트 3 이전까지는 모든 할당은 커널 풀에서 이루어져야한다.

풀의 추적 : 비트맵 (풀에서 페이지 하나당 한 비트)
n개의 페이지 할당 요청 -> 비트맵 스캔해서 false로 설정된 연속적인 비트 찾음 -> 비트들 true로 변경 (first fit)

한 개의 페이지를 요청할 때는 단편화로 인해 실패하는 경우가 발생하지 않으므로 여러개의 연속적인 페이지를 요청하는 것은 가능한 한 제한되어야한다.
페이지는 인터럽트 컨텍스트에서 할당될 수 없지만 해제될 수는 있다. (뭔소리고)
페이지가 해제될 때 페이지의 모든 바이트들은 0xcc로 클리어된다.

##### 함수
```
void *palloc_get_page (enum palloc_flags flags)
void *palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
```
페이지를 획득해서 리턴한다, 실패한 경우 null 포인터를 리턴한다.

```
flag 인자들 (사용하면 어떤 결과 발생하는지 정리)
PAL_ASSERT:  페이지가 할당될 수 없는 경우 커널 패닉 발생, 커널 초기화 동안에만 사용하도록. 유저 프로세스가 커널 패닉 일으키는 것은 허용되지 않는다.
PAL_ZERO: 페이지 할당하고 리턴하기 전에 모든 바이트를 0으로 만든다.
PAL_USER: 유저풀에서부터 페이지를 획득한다. 이 플래그가 설정되어있지 않다면 커널풀로부터 페이지를 획득한다.
```

```
void palloc_free_page (void *page)
void palloc_free_multiple (void *pages, size_t page_cnt)
```
페이지를 free 해준다. 

#### 블록 할당기
threads/malloc.h에 선언되어 있다.
다양한 크기의 블록을 할당할 수 있다.
페이지 할당기 위에 계층화되어 있다.
블록 할당기에서 반환된 블록은 커널 풀에서 얻는다.
malloc, calloc, realloc, free

### Virtual Addresses
64-bit 가상 주소의 구조
![image](https://github.com/user-attachments/assets/9d4c72b2-023e-41a6-8773-7a3126e70b7d)

inclued/threads/vaddr.h, include/threads/mmu.h가 가상주소를 다루기 위한 함수와 매크로들을 정의하고 있다.

```
#define KERN_BASE { /* Omit details */ } : 커널 가상 메모리의 기본 주소 :0x800400000, 유저 가상 메모리 : 0부터

```
물리 주소에 KERN_BASE 를 더하면 커널 가상 주소를 얻을 수 있고, 반대로 생각해보면, 커널 가상 주소에서 KERN_BASE 를 빼주면 물리 주소를 얻을 수 있습니다.


## PROJECT 2: USER PROGRAM
### Introduction
프로그램이 시스템 콜을 통해서 OS와 상호 작용할 수 있도록 만들어야한다.
시스템의 중요한 부분에 접근하기 위해서는 특권이 필요하다. -> 사용자모드와 커널모드로 나뉘는 이유
한 번에 하나 이상의 프로그램이 실행될 수 있도록 한다. -> 각각의 프로세스들은 하나의 스레드를 가진다.

응용프로그램이 시스템 콜을 호출하면 하드웨어는 ‘트랩 핸들러’를 실행하여 하드웨어 특권 수준을 커널모드로 격상시킴.
커널모드에서 운영체제는 시스템 하드웨어를 자유롭게 접근할 수 있다.

```
process.c, process.h : ELF 실행파일들을 로드하고 프로세스를 실행한다.
syscall.c, syscall.h : 유저 프로세스가 일부 커널 기능에 접근하려고 할때마다 호출된다. 현재는 메세지 출력하고 유저 프로세스 종료시키게 되어있다.
syscall-entry.S : 시스템 콜 핸들러를 부트스트랩하는 어셈블리 코드
exception.c, exception.h : 유저 프로그램이 특별한 접근 권한을 필요로 하거나 금지된 연산 수행할 때 exception 또는 fault로 커널 내로 트랩한다. 이 페이지 내에 있는 page_fault() 수정하기
gdt.c, gdt.h : GDT (사용중인 세그먼트들을 알려주는 표)를 셋업한다. 수정 필요 X
```

파일 시스템 코드와 인터페이스 해야한다. 파일 시스템 사용하는 방법과 제약사항 이해하고 싶으면 file.h와 filesys.h 보기
이 코드들은 수정할 필요없다.
- 내부 동기화 하지말것 : 한 번에 하나의 프로세스만이 파일 시스템 코드를 실행하기
- 파일 사이즈는 파일 생성시 고정된다.
- 파일의 데이터는 single extent로 할당된다. 즉 한 파일의 데이터는 디스크 섹터를 연속적으로 차지해야한다.
- 하위 디렉토리 만들지 말 것
- 파일 이름 14자로 제한
- 연산중에 시스템 crash가 발생하면 자동으로 복구되지 못하는 방식으로 디스크를 망칠 수 있다.

삭제된 파일이라도 그 파일을 열었던 스레드들이 닫아주지 않으면 블록이 할당 해제 되지 않는다.
pintos -p file -- -q : 파일 복사하기, 가져오기 : -p를 -g로 바꿀것

핀토스에서는 어느 시스템 콜도 메모리 할당을 허락하지 않기 때문에 malloc은 구현할 수 없다.

핀토스의 가상메모리는 유저 가상메모리, 커널 가상 메모리 2가지 영역으로 나뉜다.
하나의 프로세스는 하나의 유저 가상 메모리를 가진다. 프로세스 문맥 교환이 일어날 때 커널은 유저 가상 주소 공간도 바뀌어야한다.
커널 가상 메모리는 전역적이다. 커널 가상 메모리는 물리 메모리와 일대일 매핑된다.
유저 프로그램은 유저 가상 메모리에만 접근할 수 있다. 유저 프로그램이 커널 가상 메모리에 접근하려고 하면 page fault가 발생한다.
커널 스레드는 커널 가상 메모리에 접근할 수 있고, running 중인 유저 프로세스의 유저 가상 메모리도 접근할 수 있다.

커널은 유저가 null 포인터나 매핑되지않은 가상주소를 가리키닌 포인터 혹은 커널 가상 메모리 공간을 가리키는 포이너들을 잘 걸러야한다.
유저가 잘못 전달한 포인터 대응하기
1. 먼저 검사하고 그다음에 역참조
2. 유저가 전달한 포인터 kern_base보다 아래부분 가리키고 있는지 검사하고 역참조

## 시스템 콜
syscall.c 안에 시스템 콜 핸들러를 구현하자
시스템 콜 번호를 받아오고 어떤 시스템 콜 인자들을 받아오고 그에 알맞은 액션을 취해야한다.
%rax : 시스템 콜 번호
syscall_handler() 가 제어권을 얻으면 시스템 콜 번호는 rax 에 있고, 인자는 %rdi, %rsi, %rdx, %r10, %r8, %r9 순서로 전달된다.
함수 리턴 값을 위한 x86-64의 관례는 그 값을 RAX 레지스터에 넣는 것 이다. 값을 리턴하는 시스템 콜도 struct intr_frame의  rax 멤버를 수정하는 식으로 이 관례를 따를 수 있다.

구현해야하는 시스템 콜 : include/lib/user/syscall.h 시스템 콜 번호는 lib/syscall-nr.h에 정의 되어있다.
- halt: power_off() 호출해서 핀토스 종료하기 (src/include/threads/init.h 안에 파워오프 있음)
- exit : 현재 동작중인 유저 프로그램 종료 커널에 상태를 리턴하면서 종료, 관례적으로 상태가 0이면 성공 아니면 에러
- fork : 현재 프로세스의 복제본인 새 프로세스 만들기, 자식 프로세스의 pid를 반환해야한다.
- exec : 현재 코드가 cmd_line에서 이름이 주어지는 실행가능한 프로세스로 변경된다. 성공시에는 아무 것도 반환하지 않고 아니면 -1등을 반환한다. file descriptor는 exec 함수 호출시 열린 상태로 있다
- wait : 자식 프로세스를 기다려서 자식의 종료 상태를 가져오고, 아직 살아있으면 종료될 때 까지 기다린다.
- 최초의 process가 종료되기 전에 핀토스가 종료되면 안된다.
- create : 이름, 크기가 주어진 파일을 생성한다. true or false 반환 (파일 여는 것 아님)
- remove : 이름이 주어진 파일을 삭제한다 t/f 반환 (파일 닫는 것 아님)
- open : 이름이 주어진 파일을 연다. 0/-1 반환
- 각각의 프로세스는 독립적인 파일 식별자를 갖는다. 파일 식별자는 자식 프로세스에게 상속된다.
- 파일이 두 번 이상 열리면 그때마다 open 시스템콜은 새로운 식별자를 반환한다.
- filesize: 열려있는 파일의 크기가 몇 바이트인지 반환
- read : 열려있는 파일로부터 size 바이트를 읽음 일어낸 바이트의 수 반환
- write : 실제로 적힌 바이트 수를 적어준다.
- seek : fd에서 읽거나 쓸 다음 바이트를 position으로 변경한다.
- tell : 열러진 파일 fd에서 읽히거나 써질 다음 바이트의 위치를 반환한다.
- close : 파일 식별자 fd를 닫는다.

x86-64 방식의 calling convention : 인자가 6개 이하면 rdi, rsi, rdx, rcx, r8,r0 순서로 레지스터에 넣고 함수를 호출한다. 리턴 값이 있으면 rax 레지스터에 값을 담아 리턴한다.

# 개념 정리
syscall 요청이 들어올 경우 syscall.c에 있는 syscall handler가 호출되면서 필요한 syscall을 실행시키는 것이 주요 과정이다.
어떤 syscall을 호출할지는 rax 레지스터에 무슨 값이 들어있는지를 판단해서 호출한다. 해당 syscall을 호출할 때 필요한 인자 또한rdi, rsi, rdx, r10, r8, r9 순서로 레지스터에 인자가 들어있다.
해당 레저스터들은 인자로 넣어준 intr_frame 내에 멤버로 들어가 있다.
xxx syscall을 구현하기 위해서 process_xxx 또는 filesys_xxx 함수를 이용한다. -> 해당 코드 보면 힌트 얻을 수 있음

x86-64 규약에서 시스템 콜의 레지스터 사용하기
intr_frame f로부터 시스템 콜 번호와 시스템 콜 인자, 시스템 콜의 반환값을 가져오고 저장할 수 있다.
f->R.rax : 시스템 콜 번호 가져오기
f->R.rdi, f->R.rsi ... : 시스템 콜의 인자 가져오기 (rdi, rsi, rdx, rcs, r8, r9의 순서)
f->R.rax에 반환값 저장
