# 너무 꺾여버려서 다시 처음부터 정리하는 VM

지금까지의 핀토스 : 실행할 수 있는 프로그램의 수와 사이즈가 메인 메모리 사이즈에 따라서 제한 되었었다.
하지만 무한한 메모리가 있다고 생각하게 만드는 메모리의 환상을 만들어서 이러한 제한을 제거하는 것이 이번 프로젝트의 목표이다.

VM을 지원하기 위해서는 virtual page와 physical frame을 효율적으로 관리해야한다.

## Page
가상 페이지라고도 불리는 가상 메모리의 연속적인 영역
4096 bytes의 크기를 가지고, 페이지의 시작 주소도 이 크기를 바탕으로 이루어져야 한다.
따라서 64비트 체제에서 마지막 12비트는 오프셋이 되고, 나머지 비트는 페이지 테이블의 인덱스로 사용된다.
근데, 이때 이 테이블은 4단계로 나누어지고 PML4 - PDP - PD - PT의 순서로 각각의 테이블의 엔트리를 가리키게 된다.
즉, PML4에서 시작해서 나중에는 실제 물리 페이지를 가리키게 된다.

프로세스마다 각각의 페이지 모임을 갖게 되고 이 페이지들은 KERN_BASE아래에 존재하게 된다. (유저 페이지)
즉, 유저 가상 메모리 : 0 ~ KERN_BASE (하나의 프로세스는 하나의 유저 가상 메모리를 가진다.) -> 스레드 구조체가 하나의 페이지 테이블을 가리키는 포인터를 가지고 있다.
커널 가상 메모리 : KERN_BASE ~ (물리 메모리와 일대일 매핑된다.)
전역적으로 선언되는 페이지는 커널 페이지라고 불리면서 어떤 프로세스가 실행되어도 같은 위치에 있다.

## Frames
물리 주소의 연속적인 영역 페이지와 같은 사이즈로 나누어진다. -> 따라서 얘도 하위 12 비트는 오프셋으로 사용한다.
그리고 나머지는 frame number가 되면서 물리 메모리의 특정 주소의 시작 위치를 가리킨다.
x86-64 체제에서는 물리 주소에 직접적인 접근을 할 수 없고, 커널 가상 메모리와 물리 주소를 매핑하면서 접근해야한다.
핀토스에서 변환을 수행하는 함수를 제공한다. (ptov, vtop)

## Page tables
가상 주소를 물리 주소로 변환하는데 사용되는 자료구조 (PML4~, 4단계 아키텍쳐 구조) 이때 오프셋은 늘 똑같다.
하지만 현재의 페이지 테이블은 단순하게 각 주소를 포인팅하는 역할만 하기 때문에 페이지가 현재 물리 메모리에 적재되어있는지, 수정되었는지의 정보를 
저장해서 페이지들을 관리하기 위한 추가적인 보조 페이지 테이블이 필요하다. -> SPT 테이블
이와 비슷한 역할을 하는 하드웨어 디바이스는 MMU이다.
왜 다단계 페이지 테이블을 쓸까? 
-> TLB : 메모리 공간 복잡도 효율성 증

## SWAP slots
물리 메모리의 공간이 부족하게되는 경우 물리 메모리에 적재되어 있던 페이지를 이동 시키는 공간으로 디스크의 일부분이다.
swap out 되어서 swap slot에 적재되는 페이지들은 file backed page가 아니다.
왜냐하면 file backed 페이지들은 이미 파일에 정보들이 저장되어 있기 때문에 나중에 다시 해당 부분을 파일에서 가져오면 되기 때문에

## Supplemental Page Table
페이지에 대해서 추가적으로 필요한 정보를 저장하는 테이블 (왜냐하면 기존의 페이지 테이블은 단순히 위치를 포인팅 해주기만 했으므로)
2가지 용도로 사용된다.
1. 페이지 폴트가 발생했을 때 spt에서 적재해주어야하는 페이지를 찾는데 사용
2. 페이지가 종료되면 해제해줘야하는 자원을 찾을 때 사용
프로세스 마다 존재하는 자료구조이면서 각각의 페이지에 대해서 데이터가 존재하는 곳, 이에 상응하는 커널 가상 주소를 가리키는 포인터 정보, 페이지와 관련된 추가 정보 등을 담고 있다.

## Page Fault
이제 페이지 폴트는 오류가 아니라 진짜 유효하지 않은 접근 / 유효한 접근했는데 원하는 페이지가 적재되지 않아서 해당 페이지를 가져와야 하는 경우 두 가지로 나뉘게 된다.

## Frame Table
각각의 프레임에 대한 하나의 엔트리 -> 현재 해당 프레임을 점유하고 있는 페이지의 포인터랑 기타 데이터를 갖고 있는다.
프레임 테이블에서 사용 가능한 테이블이 없을 경우 (즉, 물리 메모리 꽉 찬 경우) 프레임에 할당된 페이지 중 어떤 페이지를 내쫓게 된다 (eviction)
유저 페이지에서 사용될 프레임들은 palloc_get_page(PAL_USER)을 통해서 user pool에서 부터 불러와져야한다. (안 그러면 커널 풀에서 할당된다.)
제거할 페이지 선택할 때는 페이지 교체 알고리즘을 사용해야하고 프레임을 참조하는 페이지 테이블로부터 프레임에 대한 참조를 제거해야한다.

## ACcessed and Dirty Bits
페이지 테이블 엔트리의 한 쌍의 비트들로 페이지 교체 알고리즘 등에 사용된다!
Accessed Bit: 프로세스가 페이지에 읽기나 쓰기로 접근하면 비트가 1로 변경된다.
Dirty Bit : 페이지의 내용이 수정되면 1로 변경된다. -> 스왑아웃할 때 dirty bit가 1이면 변경사항 저장해야함, 그리고 저장해줄 때 다시 0으로 바꿔준다.
이 비트들을 0으로 되돌리는 것은 CPU가 할 수 없고, OS가 해주어야한다.

## Aliase Frame
하나의 물리적 프레임을 여러 개의 페이지 테이블 엔트리가 참조하는 경우 -> 즉, 같은 물리 메모리 영역이 여러 가상 주소를 통해 접근될 수 있다.
하지만 Accessed bit랑 dirty bit는 페이지 테이블 엔트리에 저장되는 것이지 물리적 프레임에 저장되지 않기 때문에
어떤 한 프레임에 여러개의 페이지가 참조하고 있고, 어떤 페이지의 accessed bit랑 dirty bit가 변경되어도 해당 프레임을 참조하는 모든 페이지의 비트들이 변경되는 것은 아니라는 말이다.
이때, 유저 페이지의 비트들은 업데이트 되는데 커널 페이지들의 비트들은 업데이트 되지 않는 문제가 발생할 수 있다.
따라서 사용자 가상 주소랑 커널 가상 주소의 페이지들을 동기화해주거나, 커널이 사용자 가상 주소를 통해서만 사용자 데이터에 액세스하도록 하는 방법이 필요하다.

## Swap Table
사용 중인 스왑 슬롯이랑 사용 가능한 스왑 슬롯을 구분할 수 있게 추적하는 테이블 

## Memory mapped files
mmap 시스템 콜을 사용하여서 파일을 메모리 가상 주소 공간에 직접 매핑할 수 있다. 그러면 프로그램은 파일 데이터를 읽거나 수정할 때 명시적인 read나 write 시스템 콜 없이 메모리 접근 연산으로 (포인터 연산) 등으로 파일에 접근할 수 있다.
